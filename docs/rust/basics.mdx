---
sidebar_position: 2
---
# Rust'Ä±n Temelleri

Bu bÃ¶lÃ¼mde bir Rust programÄ±nÄ±n temel konularÄ±na giriÅŸ yapacaÄŸÄ±z. Bunlar bÃ¼tÃ¼n programlama dillerinde olan ya da birbirlerine
benzeyen temel kavramlardan bazÄ±larÄ±nÄ± iÃ§ermektedir.

## Hello World

Cargo ile oluÅŸturduÄŸumuz bir projede varsayÄ±lan olarak ekrana "Hello World!" yazdÄ±rÄ±lan kÃ¼Ã§Ã¼k bir programla baÅŸlanÄ±r. "src" dosyasÄ±nÄ±n
iÃ§erisindeki main.rs adlÄ± dosyayÄ± aÃ§tÄ±ÄŸÄ±mÄ±zda aÅŸaÄŸÄ±daki kod sÃ¶z dizimini gÃ¶rÃ¼rÃ¼z:

```js
fn main() {
    println!("Hello, world!");
}
```
Bu kod satÄ±rlarÄ±nda "main" adÄ±nda bir fonksiyon tanÄ±mlÄ±dÄ±r. `main` Ã¶zel bir fonksiyondur, bÃ¼tÃ¼n Rust programlarÄ± bu fonksiyonla baÅŸlar.
`fn` anahtar sÃ¶zcÃ¼ÄŸÃ¼ ile bir fonksiyon tanÄ±mlanacaÄŸÄ± belirtilir ve ardÄ±ndan bu fonksiyonun adÄ± yazÄ±lÄ±r. Fonksiyon adÄ±ndan sonra
parantez aÃ§Ä±larak fonksiyonun parametreleri girilir, parametre almayacaksa boÅŸ bÄ±rakÄ±lÄ±r. Fonksiyonun iÃ§erdiÄŸi kodlar iÃ§in bir
sÃ¼slÃ¼ parantez aÃ§Ä±lÄ±r, buna fonksiyon gÃ¶vdesi denir.

`main` fonksiyonunun gÃ¶vdesinde iÃ§erdiÄŸi metni ekrana yazdÄ±ran bir kod satÄ±rÄ± bulunur. Rust'ta ekrana metin vb bir ÅŸey yazdÄ±rmak iÃ§in
`println!()` makrosu kullanÄ±lÄ±r.

Rust'ta bir kod satÄ±rÄ± ifadesi (expression) mutlaka noktalÄ± virgÃ¼l (;) ile sonlandÄ±rÄ±lmalÄ±dÄ±r. NoktalÄ±
virgÃ¼l ile sonlandÄ±rÄ±lmayan durumlar da mevcuttur, bunlarÄ± ilerleyen konularda yeri geldiÄŸinde belirteceÄŸiz.

### Rust Projesini Derlemek ve Ã‡alÄ±ÅŸtÄ±rmak

Bir Rust projesini Ã§alÄ±ÅŸtÄ±rmadan Ã¶nce onu derlemeniz (compile) gerekir. Derleme iÅŸlemi yazdÄ±ÄŸÄ±nÄ±z kodlarÄ±n makine diline Ã§evrilerek
bilgisayarÄ±n Ã§alÄ±ÅŸtÄ±rabileceÄŸi formata getirilmesidir. Bunun iÃ§in `cargo build` komutu kullanÄ±larak derleme iÅŸlemi yapÄ±lÄ±r, derleme
bittikten sonra dosya aÄŸacÄ±nda `target` adlÄ± bir klasÃ¶r ve `Cargo.lock` adlÄ± bir dosya belirir.

`target` klasÃ¶rÃ¼ iÃ§erisinde programÄ±nÄ±zÄ±n derlendikten sonraki Ã§alÄ±ÅŸtÄ±rÄ±labilir (executable) dosyasÄ± bulunur. `Cargo lock` dosyasÄ± iÃ§ine ise
programÄ±nÄ±zÄ±n baÄŸÄ±mlÄ±lÄ±klarÄ± (dependencies) hakkÄ±nda bir takÄ±m bilgiler otomatik olarak kaydedilir.

 `cargo build` komutu ile programÄ±nÄ±z derlenir ancak Ã§alÄ±ÅŸtÄ±rÄ±lmaz, Ã§alÄ±ÅŸtÄ±rmak iÃ§in `cargo run` komutu ile programÄ±nÄ±zÄ± Ã§alÄ±ÅŸtÄ±rabilirsiniz.
EÄŸer en baÅŸta `cargo build` demeden sadece `cargo run` komutunu Ã§alÄ±ÅŸtÄ±rÄ±rsanÄ±z programÄ±nÄ±z Ã¶nce otomatik olarak derleme iÅŸlemini yapar sonra Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r.

## Veriler ve Veri tipleri

Rust programlama dilinde her deÄŸerin bir tipi vardÄ±r ve verilere tip atamasÄ± statik olarak yapÄ±lÄ±r. Yani Rust, derleme zamanÄ±nda bÃ¼tÃ¼n verilerin
tipini atanmÄ±ÅŸ olarak bilmek ister. EÄŸer verilerin tipi manuel olarak atanmamÄ±ÅŸsa kendisi bir Ã§Ä±karÄ±m yaparak varsayÄ±lan tip atamasÄ±nÄ±
otomatik olarak yapar. Verinin tipini Ã§Ä±karamadÄ±ÄŸÄ± durumlarda ise uyarÄ± vererek mutlaka tip atamasÄ±nÄ±n yapÄ±lmasÄ±nÄ± ister.

### DeÄŸiÅŸken Atamak

```js
fn main() {
    // deÄŸiÅŸken atamak iÃ§in let anahtar sÃ¶zcÃ¼ÄŸÃ¼nÃ¼ kullanÄ±rÄ±z
    let x = 1;
}
```

YukarÄ±daki kod blokunda ilk satÄ±rda `//` ile baÅŸlayan kÄ±sÄ±m yorum satÄ±rÄ±dÄ±r ve derleyici tarafÄ±ndan gÃ¶rmezden gelinir. Yorum satÄ±rlarÄ±nÄ±n amacÄ± kod okunurluÄŸunu
ve anlaÅŸÄ±lÄ±rlÄ±ÄŸÄ±nÄ± arttÄ±rmaktÄ±r.

Rust'ta deÄŸiÅŸken tanÄ±mlamak iÃ§in `let` anahtar sÃ¶zcÃ¼ÄŸÃ¼ kullanÄ±lÄ±r. Bu bÃ¼tÃ¼n veri tipleri iÃ§in geÃ§erlidir.
YukarÄ±daki kod blokunda let anahtar sÃ¶zcÃ¼ÄŸÃ¼ kullanÄ±larak "x" adlÄ± bir deÄŸiÅŸken tanÄ±mlanmÄ±ÅŸ ve deÄŸeri 1'e eÅŸittir.

Rust'ta her deÄŸiÅŸkenin bir tipi vardÄ±r ve atanmak zorundadÄ±r. EÄŸer deÄŸiÅŸkenin tipini atamazsanÄ±z Rust arka planda varsayÄ±lan olarak tanÄ±mlanan
tip atamasÄ±nÄ± yapar. Ã–rneÄŸin yukarÄ±daki "x" deÄŸiÅŸkenini deÄŸeri bir `integer` yani tam sayÄ±dÄ±r ve biz tip atamasÄ±nÄ± yapmadÄ±ÄŸÄ±mÄ±z iÃ§in
Rust arka planda integer iÃ§in varsayÄ±lan olan "i32" tipini atar.

Manuel olarak tip atamasÄ± ise ÅŸu ÅŸekilde yapÄ±lÄ±r:

```
let x: i32 = 1;
```

### Verilerin DeÄŸiÅŸtirilmezliÄŸi

Rust'ta deÄŸiÅŸkenler ilk atandÄ±ÄŸÄ±nda varsayÄ±lan olarak "immutable" yani deÄŸiÅŸtirilemez olarak tanÄ±mlanÄ±rlar.
AÅŸaÄŸÄ±daki kodu derlediÄŸinizde hata verecektir:

```js
fn main() {
    let x: i32 = 1;
    x = 5;
}
```

"x" deÄŸiÅŸkeninin deÄŸerini 5 yapmaya Ã§alÄ±ÅŸtÄ±ÄŸÄ±mÄ±zda hata alÄ±rÄ±z Ã§Ã¼nkÃ¼ varsayÄ±lan olarak x deÄŸiÅŸkeni deÄŸiÅŸtirilemez.
Rust'ta bir deÄŸiÅŸkeni deÄŸiÅŸtirebilmek iÃ§in `mut` anahtar sÃ¶zcÃ¼ÄŸÃ¼ kullanÄ±lmalÄ±dÄ±r.

```js
fn main() {
    let mut x: i32 = 1; // x'in deÄŸeri 1'e eÅŸit
    x = 5; // artÄ±k x'in deÄŸeri 5'e eÅŸit
}
```
### Sabit deÄŸerler

Sabit deÄŸerler (constants) "mut" anahtar sÃ¶zcÃ¼ÄŸÃ¼nÃ¼n kullanÄ±lamadÄ±ÄŸÄ± ve hiÃ§bir zaman deÄŸiÅŸtirilmeyen deÄŸerlerdir. `let` yerine
`const` anahtar sÃ¶zcÃ¼ÄŸÃ¼ alarak atanÄ±rlar ve tip atamasÄ± mutlaka yapÄ±lmalÄ±dÄ±r. Sabit deÄŸerlerin adlarÄ± her zaman bÃ¼yÃ¼k harflerle yazÄ±lÄ±r.

```js
const MYVAL: i32 = 61;
```

### Skaler Veri tipleri

Skaler tipler tek bir deÄŸere eÅŸit olan veri tipleridir, yani birden fazla deÄŸiÅŸkeni tutmak iÃ§in kullanÄ±lmazlar. Rust'ta dÃ¶rt farklÄ±
skaler veri tipi vardÄ±r: tam sayÄ±lar (integers), kayan noktalÄ± sayÄ±lar (floating point numbers), mantÄ±ksallar (booleans) ve karakterler (characters).

#### Tam sayÄ±lar

Tam sayÄ±lar adÄ±ndan da anlaÅŸÄ±lacaÄŸÄ± Ã¼zere kesirli bileÅŸeni olmayan sayÄ±lardÄ±r. DoÄŸal sayÄ±lar ve onlarÄ±n negatiflerinden oluÅŸurlar.
Rust'ta kapladÄ±ÄŸÄ± boyuta gÃ¶re birden fazla tam sayÄ± tipi bulunur.

| **Boyut** | **Ä°ÅŸaretli** | **Ä°ÅŸaretsiz** |
| :----- | :----: | ----: |
| 8-bit| i8 | u8 |
| 16-bit | i16  |  u16 |
| 32-bit | i32 | u32 |
| 64-bit | i64 | u64 |
| 128-bit | i128 | u128 |

YukarÄ±daki tabloda Rust'ta bir tam sayÄ±nÄ±n alabileceÄŸi tipler listelenmektedir. Ä°ÅŸaretli tipler negatif sayÄ± da alabilirken iÅŸaretsiz tipler
sadece pozitif sayÄ±lardan oluÅŸur. Her tam sayÄ± deÄŸerinin boyutu atandÄ±ÄŸÄ± tipe gÃ¶re deÄŸiÅŸir. Ã–rneÄŸin sayÄ±nÄ±n tipi `i16` ise bellekte 16 bit yer kaplar,
Her tip iÃ§in belli aralÄ±klarda sayÄ±lar tutulabilir, bunun iÃ§in bir formÃ¼l kullanÄ±larak o tipin o sayÄ±yÄ± saklayÄ±p saklayamayacaÄŸÄ± anlaÅŸÄ±labilir:

`n` bit sayÄ±sÄ±nÄ± temsil etmek Ã¼zere iÅŸaretli sayÄ±lar iÃ§in `-(2^(n - 1)) den 2^(n - 1) - 1 e kadar` iÅŸaretsiz sayÄ±lar iÃ§in `0 dan 2^n - 1 e kadar` olan aralÄ±ktaki sayÄ±lar o tamsayÄ± tipi iÃ§in
o deÄŸeri alabilir.

Ã–rneÄŸin "i8" tipinde bir tam sayÄ± n=8 olmak Ã¼zere formÃ¼lde yerleÅŸtirip iÅŸlem yapÄ±ldÄ±ÄŸÄ±nda -128 ile 127 aralÄ±ÄŸÄ±nda bÃ¼tÃ¼n sayÄ±larÄ± tutabilir. EÄŸer bu sayÄ± aralÄ±ÄŸÄ±nda
olmayan Ã¶rneÄŸin 211 sayÄ±sÄ± i8 tipinde tutulmak istenirse aralÄ±k dÄ±ÅŸÄ±nda olacaÄŸÄ±ndan atanamaz.

Tablodakiler dÄ±ÅŸÄ±nda tam sayÄ±lar iÃ§in atanabilecek iki tip daha vardÄ±r, bunlar `isize` ve `usize` olmak Ã¼zere iki tanedir. Bu iki tip atandÄ±ÄŸÄ±nda
bilgisayarÄ±n iÅŸlemci mimarisi kaÃ§ bitse otomatik olarak onu atat, Ã¶rneÄŸin tam sayÄ±nÄ±n tipi "isize" olarak belirlenmiÅŸse ve bilgisayar 32 bitlikse i32
olarak, 64 bitlikse i64 olarak tip atamasÄ± yapÄ±lÄ±r.

#### Kayan NoktalÄ± SayÄ±lar

Rust iki farklÄ± kayan noktalÄ± sayÄ± tipine sahiptir, bunlar `f32`ve `f64` olmak Ã¼zere 32 bitlik ve 64 bitlik olarak tanÄ±mlanÄ±rlar. EÄŸer tip atamasÄ±
manuel olarak yapÄ±lmazsa Rust derleyicisi varsayÄ±lan olarak f64 atayacaktÄ±r. Kayan noktalÄ± sayÄ±larÄ±n hepsi iÅŸaretli olarak tanÄ±mlanmÄ±ÅŸtÄ±r, yani
negatif ve pozitif deÄŸerler alabilirler.

```js
fn main() {
    let x = 3.0;  // tip atamasÄ± yapÄ±lmadÄ±ÄŸÄ±ndan varsayÄ±lan olarak f64 atanÄ±r.

    let y: f32 = 6.4;
}
```
#### SayÄ±sal Ä°ÅŸlemler

Rust'ta toplama, Ã§Ä±karma, Ã§arpma ve bÃ¶lme gibi temel matematiksel iÅŸlemler diÄŸer programlama dillerindekine benzer ÅŸekilde yapÄ±lÄ±r.
Tam sayÄ±larÄ±n bÃ¶lÃ¼mÃ¼nde Ã§Ä±kan sonuÃ§ sÄ±fÄ±ra en yakÄ±n olan tam sayÄ±ya yuvarlanÄ±r. Ã–rneÄŸin 2.8 sayÄ±sÄ± 2 ye yuvarlanÄ±r.

```js
fn main() {
    // toplama
    let toplam = 8 + 5;

    // Ã§Ä±karma
    let fark = 23.6 - 8.3;

    // Ã§arpma
    let carp = 4 * 30;

    // bÃ¶lme
    let bolum = 64.7 / 30.4;
    let x = -5 / 3; // SonuÃ§ -1 e yuvarlanÄ±r.
    let y = 14 / 5; // SonuÃ§ 2 ye yuvarlanÄ±r.

    // bÃ¶lÃ¼mden kalanÄ± bulma
    let kalan = 43 % 5;
}
```

#### MantÄ±ksal (Boolean)

DiÄŸer Ã§oÄŸu dilde olduÄŸu gibi Rust'ta da mantÄ±ksal (boolean) tipte iki deÄŸer bulunur: `true` ve `false`. `bool`
yazÄ±larak tip atamasÄ± yapÄ±lÄ±r ve bellekte 1 byte yer tutarlar.

```js
fn main() {
    let x = true;

    let y: bool = false;
}
```
#### Karakter (char)

`char` karakterleri temsil eden bir tiptir. Her karakterin bir sayÄ± karÅŸÄ±lÄ±ÄŸÄ± vardÄ±r, Ã¶rneÄŸin bÃ¼yÃ¼k harfli "M" nin
sayÄ± karÅŸÄ±lÄ±ÄŸÄ± 77, kÃ¼Ã§Ã¼k harfli "m" nin ise 109'dur. BÃ¼tÃ¼n bu numara karÅŸÄ±lÄ±klarÄ±na Unicode denilir.
Rust'ta char tipi tek tikli tÄ±rnak iÅŸaretiyle oluÅŸturulur ve bellekte 4 byte yer kaplarlar.

```js
let my_char = 'm';
let space = ' '; // boÅŸluk da bir char tipidir.
let emoji = 'ğŸ˜º' // emojiler de bir char tipidir.
```
### Koleksiyon Tipler

Koleksiyon tiplerde tek bir deÄŸer yerine birden fazla deÄŸer bir tipe atanÄ±r. Bu kÄ±sÄ±mda iki farklÄ± temel koleksiyon
tipini ele alacaÄŸÄ±z.

#### Tuple

Tuple, birden fazla deÄŸerin bir arada toplanarak tek bir tip oluÅŸturmanÄ±n yollarÄ±ndan birisidir. Tuple tipte deÄŸerler
aynÄ± ya da farklÄ± tÃ¼rde olabilir ve bir kez oluÅŸturulduktan sonra boyutu deÄŸiÅŸtirilemez, deÄŸer ekleme ya da Ã§Ä±karma yapÄ±lamaz.
Tuple oluÅŸturmak iÃ§in deÄŸerler iki parantez `()` arasÄ±na yazÄ±lÄ±r, manuel tip atamasÄ± da aynÄ± ÅŸekilde yapÄ±lÄ±r.

```js
fn main() {
    let tup: (i32, f64, u8) = (50, 6.8, 1); // tuple elemanlarÄ± farklÄ± tiplerden oluÅŸabilir
    let fifty = tup.0; // tuple elemanlarÄ±na index numarasÄ± ile eriÅŸebiliriz
    let (x, y, z) = (12, 56, 3.4); // tuple elemanlarÄ±nÄ±n her birisini bir deÄŸiÅŸkene atayabiliriz
}
```

#### Array (Dizi)

Birden fazla deÄŸeri bir tipe atamanÄ±n yollarÄ±ndan birisi de dizilerdir. Ancak dizileri oluÅŸturan elemanlarÄ±n tÃ¼rleri aynÄ± olmalÄ±dÄ±r.
Diziler de tuple gibi sabit boyuttadÄ±r, eleman ekleme ve Ã§Ä±karma yapÄ±lamaz. Array (dizi) atamasÄ± yapmak iÃ§in kÃ¶ÅŸeli parantez `[]` kullanÄ±lÄ±r.
Manuel tip atamasÄ± yaparken ilk eleman dizi elemanlarÄ±nÄ±n tipini, ikinci eleman ise dizinin boyutunu (length) belirtir.

```js
fn main() {
    let a: [i32; 6] = [1, 2, 3, 4, 5, 6]; // [i32; 6] ilk eleman tip, ikinci eleman boyut (length)
    let birinci_eleman = a[0]; // dizinin elamanlarÄ±na index numarasÄ± ile bu ÅŸekilde eriÅŸebiliriz
    let dorduncu_eleman = a[3]; // index numaralarÄ± her zaman 0 dan baÅŸlar
}
```
Bir dizinin elemanlarÄ± aynÄ± deÄŸerden oluÅŸuyorsa o diziyi ÅŸu ÅŸekilde de baÅŸlatabiliriz:

```js
fn main() {
    let a = [3; 6]; // dizinin eÅŸdeÄŸeri a = [3, 3, 3, 3, 3, 3]
}
```
YukarÄ±daki kodda dizinin ilk elemanÄ± olan 3 sayÄ±sÄ± dizimizin iÃ§indeki deÄŸeri temsil eder, ikinci elaman olan 6 sayÄ±sÄ± ise dizinin
boyutunu (length) temsil eder. O halde yukarÄ±daki dizi altÄ± tane 3 sayÄ±sÄ±ndan oluÅŸan bir dizidir.
